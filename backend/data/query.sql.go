// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package data

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLoadout = `-- name: CreateLoadout :one
INSERT INTO public.loadouts (
        title,
        source,
        source_url,
        weapon_name,
        weapon_category,
        created_by,
        game_id,
        attachments
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, created_at, updated_at, title, source, source_url, weapon_name, weapon_category, created_by, game_id, attachments
`

type CreateLoadoutParams struct {
	Title          string        `json:"title"`
	Source         pgtype.Text   `json:"source"`
	SourceUrl      pgtype.Text   `json:"sourceUrl"`
	WeaponName     string        `json:"weaponName"`
	WeaponCategory string        `json:"weaponCategory"`
	CreatedBy      pgtype.UUID   `json:"createdBy"`
	GameID         pgtype.UUID   `json:"gameId"`
	Attachments    []pgtype.UUID `json:"attachments"`
}

func (q *Queries) CreateLoadout(ctx context.Context, arg CreateLoadoutParams) (Loadout, error) {
	row := q.db.QueryRow(ctx, createLoadout,
		arg.Title,
		arg.Source,
		arg.SourceUrl,
		arg.WeaponName,
		arg.WeaponCategory,
		arg.CreatedBy,
		arg.GameID,
		arg.Attachments,
	)
	var i Loadout
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Source,
		&i.SourceUrl,
		&i.WeaponName,
		&i.WeaponCategory,
		&i.CreatedBy,
		&i.GameID,
		&i.Attachments,
	)
	return i, err
}

const listGames = `-- name: ListGames :many
SELECT id, name
FROM public.games
ORDER BY name
`

func (q *Queries) ListGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.Query(ctx, listGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoadouts = `-- name: ListLoadouts :many
SELECT id, created_at, updated_at, title, source, source_url, weapon_name, weapon_category, created_by, game_id, attachments
FROM public.loadouts
ORDER BY title
`

func (q *Queries) ListLoadouts(ctx context.Context) ([]Loadout, error) {
	rows, err := q.db.Query(ctx, listLoadouts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Loadout
	for rows.Next() {
		var i Loadout
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Source,
			&i.SourceUrl,
			&i.WeaponName,
			&i.WeaponCategory,
			&i.CreatedBy,
			&i.GameID,
			&i.Attachments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
